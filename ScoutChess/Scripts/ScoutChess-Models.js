// Generated by IcedCoffeeScript 108.0.9
(function() {
  var Piece, player1, player2, roles;

  player1 = 'brown';

  player2 = 'pink';

  roles = {
    pawn: 'pawn',
    rook: 'rook',
    knight: 'knight',
    bishop: 'bishop',
    queen: 'queen',
    king: 'king'
  };

  window.ScoutChess = function() {
    var createTeamPieces, piece, _i, _j, _len, _len1, _ref, _ref1;
    this.pieces = [];
    this.turn = player1;
    this.selectedPiece = ko.observable();
    this.selectPiece = function(p) {
      if (p.team === this.turn) {
        return this.selectedPiece(p);
      }
    };
    this.isOccupied = function(column, row) {
      return this.pieces.some(function(p) {
        return p.column() === column && p.row() === row;
      });
    };
    this.getMoves = function(p) {
      var c, dir, moves, r;
      moves = [];
      switch (p.rank) {
        case roles.pawn:
          dir = p.team === player1 ? 1 : -1;
          moves.push({
            column: p.column() + dir,
            row: p.row()
          });
          if (p.initiated == null) {
            moves.push({
              column: p.column() + dir * 2,
              row: p.row()
            });
          }
          break;
        case roles.rook:
          r = p.row() - 1;
          while (!(r < 0 || this.isOccupied(p.column(), r))) {
            moves.push({
              column: p.column(),
              row: r
            });
            r--;
          }
          r = p.row() + 1;
          while (!(r > 7 || this.isOccupied(p.column(), r))) {
            moves.push({
              column: p.column(),
              row: r
            });
            r++;
          }
          c = p.column() + 1;
          while (!(c > 7 || this.isOccupied(c, p.row()))) {
            moves.push({
              column: c,
              row: p.row()
            });
            c++;
          }
          c = p.column() - 1;
          while (!(c < 0 || this.isOccupied(c, p.row()))) {
            moves.push({
              column: c,
              row: p.row()
            });
            c--;
          }
      }
      return moves;
    };
    this.move = function(column, row) {
      if (this.selectedPiece() != null) {
        this.selectedPiece().column(column);
        this.selectedPiece().row(row);
        this.selectedPiece().initiated = true;
        this.selectedPiece(null);
        return this.turn = this.turn === player1 ? player2 : player1;
      }
    };
    createTeamPieces = function(team, isRightPlayer) {
      var b, pieces, r, s;
      s = function(fromLeft) {
        if (isRightPlayer) {
          return 7 - fromLeft;
        } else {
          return fromLeft;
        }
      };
      pieces = (function() {
        var _i, _results;
        _results = [];
        for (r = _i = 0; _i < 8; r = ++_i) {
          _results.push(new Piece(team, roles.pawn, s(1), r));
        }
        return _results;
      })();
      b = function(rank, row) {
        return pieces.push(new Piece(team, rank, s(0), row));
      };
      b(roles.rook, 0);
      b(roles.knight, 1);
      b(roles.bishop, 2);
      b(roles.queen, 3);
      b(roles.king, 4);
      b(roles.bishop, 5);
      b(roles.knight, 6);
      b(roles.rook, 7);
      return pieces;
    };
    _ref = createTeamPieces(player1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      piece = _ref[_i];
      this.pieces.push(piece);
    }
    _ref1 = createTeamPieces(player2, true);
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      piece = _ref1[_j];
      this.pieces.push(piece);
    }
    return this;
  };

  Piece = function(team, rank, column, row) {
    this.team = team;
    this.rank = rank;
    this.column = ko.observable(column);
    this.row = ko.observable(row);
    return this;
  };

}).call(this);
